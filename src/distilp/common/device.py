"""
Data classes for HALDA solver profiles.
"""

from __future__ import annotations
from typing import Dict, Optional
from pydantic import BaseModel, Field

from . import QuantizationLevel


class DeviceProfile(BaseModel):
    """
    Unified device profile for both profiler output and solver input.

    This class serves dual purposes:
    1. Profiler output: Generated by profiler/device.py with measured hardware characteristics
    2. Solver input: Used by solver components to make optimization decisions

    All fields have defaults to allow incremental construction by the profiler.
    The solver expects all required fields to be populated when loading from JSON.

    Notation in comments matches the paper's symbols.
    """

    # --- Device identification ---
    name: str = ""  # Device hostname or identifier
    os_type: str = ""  # 'mac_no_metal' | 'mac_metal' | 'linux' | 'android'
    is_head: bool = True  # I_{m=1} (True for head device holding input/output layers on CPU)
    is_unified_mem: bool = False  # I_UMA (Apple Silicon unified memory, etc.)
    has_cuda: bool = False  # I_cuda (NVIDIA CUDA availability)
    has_metal: bool = False  # I_metal (Apple Metal availability)

    # --- CPU performance characteristics ---
    # Throughput tables (FLOPS) per quantization level and batch size
    # Format: {"Q4_K": {"b_1": flops, ...}, "Q5_K": {...}, "Q6_K": {...}, "Q8_0": {...},
    #          "F16": {...}, "BF16": {...}, "F32": {...}}
    # Quantized values (Q4_K, Q5_K, Q6_K, Q8_0) are derived from F32 with empirical factors
    scpu: Dict[QuantizationLevel, Dict[str, float]] = Field(default_factory=dict)  # s^{cpu}_{m,q}
    T_cpu: float = 0.0  # T^{cpu}_m (CPU register loading throughput, bytes/s)

    # --- KV cache transfer times (seconds) ---
    # Time for fixed 2*(h_k*e_k + h_v*e_v)*n_kv byte KV cache payload transfer
    t_kvcpy_cpu: float = 0.0  # t^{kv_cpy,cpu}_m (CPU KV copy time)
    t_kvcpy_gpu: float = 0.0  # t^{kv_cpy,gpu}_m (GPU KV copy time)

    # --- Host<->GPU and inter-device communication times (seconds) ---
    t_ram2vram: float = 0.0  # t^{ram->vram}_m (RAM to VRAM transfer time)
    t_vram2ram: float = 0.0  # t^{vram->ram}_m (VRAM to RAM transfer time)
    t_comm: float = 0.0  # t^{comm}_m (inter-device communication time)

    # --- Disk I/O ---
    s_disk: float = 0.0  # s^{disk}_m (disk read throughput, bytes/s)

    # --- Memory capacity (bytes) ---
    d_avail_ram: int = 0  # d^{avail}_m (available RAM)

    # --- GPU performance characteristics (optional, device-dependent) ---
    # Throughput tables (FLOPS) per quantization level and batch size
    # Format: {"Q4_K": {"b_1": flops, ...}, "Q5_K": {...}, "Q6_K": {...}, "Q8_0": {...},
    #          "F16": {...}, "BF16": {...}, "F32": {...}}
    sgpu_cuda: Optional[Dict[QuantizationLevel, Dict[str, float]]] = None  # s^{gpu}_{m,q} for CUDA
    sgpu_metal: Optional[Dict[QuantizationLevel, Dict[str, float]]] = None  # s^{gpu}_{m,q} for Metal
    T_cuda: Optional[float] = None  # T^{gpu}_m for CUDA (GPU register loading, bytes/s)
    T_metal: Optional[float] = None  # T^{gpu}_m for Metal (GPU register loading, bytes/s)
    d_avail_cuda: Optional[int] = None  # d^{avail}_{m,cuda} (available CUDA VRAM, bytes)
    d_avail_metal: Optional[int] = None  # d^{avail}_{m,metal} (available Metal memory, bytes)

    # --- Compute buffers (bytes) ---
    c_cpu: int = 0  # c^{cpu} (CPU compute buffer size)
    c_gpu: int = 0  # c^{gpu} (GPU compute buffer size)

    # --- Swap capacity (bytes, primarily for Android) ---
    d_bytes_can_swap: int = 0  # Potential bytes available for swapping
    d_swap_avail: int = 0  # Actually available swap space

    def print_summary(self) -> None:
        """Print a summary of loaded devices."""
        ram_gb = self.d_avail_ram / (1024**3)
        print(f"   OS Type: {self.os_type}")
        print(f"   RAM: {ram_gb:.1f} GB")
        print(f"   Is Head: {self.is_head}")
        print(f"   Unified Memory: {self.is_unified_mem}")

        if self.has_cuda and self.d_avail_cuda:
            cuda_gb = self.d_avail_cuda / (1024**3)
            print(f"   CUDA: {cuda_gb:.1f} GB")

        if self.has_metal and self.d_avail_metal:
            metal_gb = self.d_avail_metal / (1024**3)
            print(f"   Metal: {metal_gb:.1f} GB")

        print(f"   Disk Speed: {self.s_disk / (1024**2):.1f} MB/s")
